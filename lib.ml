(* ========================================================================= *)
(* Useful OCaml functions.                                                   *)
(*                                                                           *)
(*                            Petros Papapanagiotou                          *)
(*              Center of Intelligent Systems and their Applications         *)
(*                           University of Edinburgh                         *)
(*                                 2010-2015                                 *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Apply a function to both members of a pair. Same as 'f ## f' in HOL4.     *)
(* ------------------------------------------------------------------------- *)

let hashf f (x,y) = (f x, f y) ;;

(* ------------------------------------------------------------------------- *)
(* Invert pairs.                                                             *)
(* Used to invert substitutions.                                             *)
(* ------------------------------------------------------------------------- *)

let invpair (x,y) = y,x;;

let invpairs l = map invpair l;;

(* ------------------------------------------------------------------------- *)
(* Function used for indented prints.                                        *)
(* ------------------------------------------------------------------------- *)

let rec print_depth depth prn arg =
  match depth with
      0 -> (prn arg ; print_newline ())
    | _ -> (print_string " " ; print_depth (depth -1) prn arg);;


(* ------------------------------------------------------------------------- *)
(* print_goalstack_all :                                                     *) 
(* Alternative goalstack printer that always prints all subgoals.            *)
(* Also prints list of metavariables with their types.                       *)
(* ------------------------------------------------------------------------- *)
(* Original printer only prints more than one subgoals iff they were         *)
(* generated by the last step. Otherwise it only prints the 'active' subgoal.*)
(* Replace by #install_printer print_goalstack_all;;                         *)
(* Revert to original by #install_printer print_goalstack;;                  *)
(* ------------------------------------------------------------------------- *)

let (print_goalstack_all:goalstack->unit) =
  let print_goalstate k gs =
    let ((mvs,_),gl,_) = gs in
    let n = length gl in
    let s = if n = 0 then "No subgoals" else
              (string_of_int k)^" subgoal"^(if k > 1 then "s" else "")
           ^" ("^(string_of_int n)^" total)" in
    let print_mv v = print_string " `" ; print_varandtype std_formatter v ; print_string "`;" in
    print_string s; print_newline();
    if (length mvs > 0) then (
      print_string "Metas:" ; let _ = map print_mv mvs in () ; print_newline()
    ) ; 
    if gl = [] then () else
    do_list (print_goal o C el gl) (rev(0--(k-1))) in
  fun l ->
    if l = [] then print_string "Empty goalstack"
    else 
      let (_,gl,_ as gs) = hd l in
      print_goalstate (length gl) gs;;


(* ------------------------------------------------------------------------- *)
(* print_thl:                                                                *)
(* Print a list of theorems (for debugging).                                 *)
(* ------------------------------------------------------------------------- *)

let print_thl thl = 
  map (fun thm -> ( print_thm thm ; print_newline ())) thl;;


(* ------------------------------------------------------------------------- *)
(* print_tml:                                                                *)
(* Print a list of terms (for debugging).                                    *)
(* ------------------------------------------------------------------------- *)

let print_tml tml = 
    map (fun tm -> ( print_term tm ; print_newline ())) tml;;


(* ------------------------------------------------------------------------- *)
(* count_goals : unit -> int                                                 *) 
(* Shortcut to count the subgoals in the current goalstate.                  *)
(* ------------------------------------------------------------------------- *)

let count_goals () =
  if (!current_goalstack = []) then 0 else
  (length o snd3 o hd) !current_goalstack;;


(* ------------------------------------------------------------------------- *)
(* top_asms : goalstack -> (string * thm) list                               *) 
(* Shortcut to get the assumption list of the top goal of a given goalstack. *)
(* ------------------------------------------------------------------------- *)

let top_asms (gs:goalstack) = (fst o hd o snd3 o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* top_metas : goalstack -> term list                                        *) 
(* Returns the list of metavariables in the current goalstate.               *)
(* ------------------------------------------------------------------------- *)
(* This also exists in Isabelle Light.                                       *)
(* ------------------------------------------------------------------------- *)

let top_metas (gs:goalstack) = (fst o fst3 o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* top_inst : goalstack -> instantiation                                     *) 
(* Returns the metavariable instantiations in the current goalstate.         *)
(* ------------------------------------------------------------------------- *)

let top_inst (gs:goalstack) = (snd o fst3 o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* e_all : tactic -> goalstack                                               *) 
(* Same as "e" but applies tactic to ALL subgoals.                           *)
(* ------------------------------------------------------------------------- *)
(* This could be done better by implementing a by_all function, but it'll    *)
(* do for now since it's rarely used anyway.                                 *) 
(* ------------------------------------------------------------------------- *)

let e_all tac =
  let c = (count_goals()) in
  let rec f i = ( 
    if (i = 0) 
    then (!current_goalstack) 
    else let _ = e tac in let _ = r 1 in f (i-1) 
   ) in f c;;


